//! Compilation - compile blueprints to Rust code

use gpui::*;
use super::core::BlueprintEditorPanel;
use ui::compiler;

impl BlueprintEditorPanel {
    /// Compile current graph to Rust source code
    pub fn compile_to_rust(&self) -> Result<String, String> {
        let graph_description = self.convert_to_graph_description()?;
        compiler::compile_graph(&graph_description)
    }

    /// Compile and save events to class directory structure
    pub fn compile_to_class_directory(&self) -> Result<(), String> {
        let class_path = self.current_class_path.as_ref()
            .ok_or("No class loaded - cannot compile")?;

        // Save variables and generate vars module first
        self.save_variables_to_class()?;
        self.generate_vars_module()?;

        // Create events directory
        let events_dir = class_path.join("events");
        std::fs::create_dir_all(&events_dir)
            .map_err(|e| format!("Failed to create events directory: {}", e))?;

        // Find all event nodes
        let event_nodes: Vec<_> = self.graph.nodes.iter()
            .filter(|node| node.node_type == super::super::NodeType::Event)
            .collect();

        if event_nodes.is_empty() {
            return Err("No event nodes found in graph".to_string());
        }

        // Compile each event individually
        let graph_description = self.convert_to_graph_description()?;
        let metadata = compiler::node_metadata::extract_node_metadata()
            .map_err(|e| format!("Failed to get node metadata: {}", e))?;

        // Build variables HashMap
        let variables: std::collections::HashMap<String, String> = self.class_variables.iter()
            .map(|v| (v.name.clone(), v.var_type.clone()))
            .collect();

        let data_resolver = compiler::data_resolver::DataResolver::build_with_variables(
            &graph_description,
            &metadata,
            variables.clone(),
        )?;
        let exec_routing = compiler::execution_routing::ExecutionRouting::build_from_graph(
            &graph_description,
        );

        let mut mod_exports = Vec::new();

        for event_node in &event_nodes {
            let graph_event = graph_description.nodes.values()
                .find(|n| n.id == event_node.id)
                .ok_or(format!("Event node {} not found in graph", event_node.id))?;

            let mut generator = compiler::code_generator::CodeGenerator::new(
                &metadata,
                &data_resolver,
                &exec_routing,
                &graph_description,
                variables.clone(),
            );

            let event_code = generator.generate_event_function(graph_event)?;
            let event_name = event_node.definition_id.to_lowercase();
            let event_file = events_dir.join(format!("{}.rs", event_name));

            std::fs::write(&event_file, &event_code)
                .map_err(|e| format!("Failed to write {}: {}", event_file.display(), e))?;

            mod_exports.push(event_name.clone());
            println!("Compiled event '{}' to {}", event_node.title, event_file.display());
        }

        // Create mod.rs
        let now = chrono::Local::now();
        let version = ui::ENGINE_VERSION;
        let mod_header = format!(
            "//! Auto Generated by the Pulsar Blueprint Editor\n\
             //! DO NOT EDIT MANUALLY - YOUR CHANGES WILL BE OVERWRITTEN\n\
             //! Generated on {} - Engine version {}\n\
             //!\n\
             //! This file re-exports all event modules for this class.\n\
             //! Individual event implementations are in separate files.\n\
             //! To modify events, open the class in the Pulsar Blueprint Editor.\n\
             //!\n\
             //! EDITING ANYTHING IN THIS FILE COULD BREAK THE EDITOR\n\
             //! AND PREVENT THE GUI FROM OPENING THIS CLASS - BE CAREFUL\n\n",
            now.format("%Y-%m-%d %H:%M:%S"),
            version
        );

        let mod_exports_str = mod_exports.iter()
            .map(|name| format!("pub mod {};\npub use {}::*;", name, name))
            .collect::<Vec<_>>()
            .join("\n");

        let mod_content = format!("{}{}", mod_header, mod_exports_str);
        let mod_path = events_dir.join("mod.rs");
        std::fs::write(&mod_path, mod_content)
            .map_err(|e| format!("Failed to write mod.rs: {}", e))?;

        Ok(())
    }

    /// Start compilation (called from toolbar)
    pub fn start_compilation(&mut self, cx: &mut Context<Self>) {
        let panel_entity = cx.weak_entity();
        cx.spawn(async move |_entity, mut cx| {
            Self::compile_async(panel_entity, &mut cx).await;
        })
        .detach();
    }

    /// Compile in background with status updates
    pub async fn compile_async(panel_entity: gpui::WeakEntity<Self>, cx: &mut gpui::AsyncApp) {
        // Set compiling state
        let result = panel_entity.update(cx, |panel, cx| {
            panel.compilation_status = super::super::CompilationStatus {
                state: super::super::CompilationState::Compiling,
                message: "Compiling blueprint...".to_string(),
                progress: 0.0,
                is_compiling: true,
            };
            cx.notify();
            panel.compile_to_class_directory()
        });
        
        if let Ok(compile_result) = result {
            match compile_result {
                Ok(()) => {
                    // Success
                    smol::Timer::after(std::time::Duration::from_millis(500)).await;
                    let _ = panel_entity.update(cx, |panel, cx| {
                        panel.compilation_status = super::super::CompilationStatus {
                            state: super::super::CompilationState::Success,
                            message: "✓ Compilation successful".to_string(),
                            progress: 1.0,
                            is_compiling: false,
                        };
                        
                        // Add to history
                        let now = chrono::Local::now();
                        panel.compilation_history.push(super::core::CompilationHistoryEntry {
                            timestamp: now.format("%H:%M:%S").to_string(),
                            state: super::super::CompilationState::Success,
                            message: "Compilation successful".to_string(),
                        });
                        
                        cx.notify();
                    });
                }
                Err(e) => {
                    // Compilation error
                    let _ = panel_entity.update(cx, |panel, cx| {
                        panel.compilation_status = super::super::CompilationStatus {
                            state: super::super::CompilationState::Error,
                            message: format!("✗ Compilation failed: {}", e),
                            progress: 0.0,
                            is_compiling: false,
                        };
                        
                        // Add to history
                        let now = chrono::Local::now();
                        panel.compilation_history.push(super::core::CompilationHistoryEntry {
                            timestamp: now.format("%H:%M:%S").to_string(),
                            state: super::super::CompilationState::Error,
                            message: format!("Compilation failed: {}", e),
                        });
                        
                        cx.notify();
                    });
                }
            }
        } else {
            // Panel entity no longer exists - try to update anyway
            let _ = panel_entity.update(cx, |panel, cx| {
                        panel.compilation_status = super::super::CompilationStatus {
                            state: super::super::CompilationState::Error,
                            message: "✗ Compilation failed: panel closed".to_string(),
                            progress: 0.0,
                            is_compiling: false,
                        };
                        cx.notify();
                    });
        }

        // Clear status after 3 seconds
        smol::Timer::after(std::time::Duration::from_secs(3)).await;
        let _ = panel_entity.update(cx, |panel, cx| {
            if panel.compilation_status.state != super::super::CompilationState::Compiling {
                panel.compilation_status = super::super::CompilationStatus::default();
                cx.notify();
            }
        });
    }
}
