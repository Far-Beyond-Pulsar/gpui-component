use gpui::{prelude::*, *};
use ui::{
    ActiveTheme, Root, Sizable, StyledExt,
    button::{Button, ButtonVariants as _},
    h_flex, v_flex, IconName, Icon,
    text::TextView,
    code_block::StyledCodeBlock,
};
use pulsar_docs::{get_doc_content, get_crate_index, list_crates, docs_available, CrateIndex};
use std::collections::HashMap;

pub struct DocumentationWindow {
    focus_handle: FocusHandle,
    current_path: Option<String>,
    tree_items: Vec<TreeNode>,
    flat_visible_items: Vec<usize>, // Indices into tree_items
    expanded_paths: HashMap<String, bool>,
    markdown_content: String,
}

#[derive(Clone, Debug)]
enum TreeNode {
    Crate {
        name: String,
        index: CrateIndex,
        depth: usize,
    },
    Section {
        crate_name: String,
        section_name: String,
        count: usize,
        depth: usize,
    },
    Item {
        crate_name: String,
        section_name: String,
        item_name: String,
        path: String,
        doc_summary: Option<String>,
        depth: usize,
    },
}

impl DocumentationWindow {
    pub fn new(_window: &mut Window, cx: &mut Context<Self>) -> Self {
        let mut window = Self {
            focus_handle: cx.focus_handle(),
            current_path: None,
            tree_items: Vec::new(),
            flat_visible_items: Vec::new(),
            expanded_paths: HashMap::new(),
            markdown_content: "# Pulsar Engine Documentation\n\nSelect an item from the sidebar to view its documentation.".to_string(),
        };
        
        window.load_documentation();
        window
    }
    
    fn load_documentation(&mut self) {
        if !docs_available() {
            self.markdown_content = "# No Documentation Available\n\nDocumentation has not been generated yet. Build in release mode to generate docs.".to_string();
            return;
        }
        
        // Build flat tree structure
        for crate_name in list_crates() {
            if let Some(index) = get_crate_index(&crate_name) {
                // Add crate node
                self.tree_items.push(TreeNode::Crate {
                    name: crate_name.clone(),
                    index: index.clone(),
                    depth: 0,
                });
                
                // Add section nodes
                for section in &index.sections {
                    self.tree_items.push(TreeNode::Section {
                        crate_name: crate_name.clone(),
                        section_name: section.name.clone(),
                        count: section.count,
                        depth: 1,
                    });
                    
                    // Add item nodes
                    for item in &section.items {
                        self.tree_items.push(TreeNode::Item {
                            crate_name: crate_name.clone(),
                            section_name: section.name.clone(),
                            item_name: item.name.clone(),
                            path: format!("{}/{}", crate_name, item.path),
                            doc_summary: item.doc_summary.clone(),
                            depth: 2,
                        });
                    }
                }
            }
        }
        
        self.rebuild_visible_list();
    }
    
    fn rebuild_visible_list(&mut self) {
        self.flat_visible_items.clear();
        
        for (idx, node) in self.tree_items.iter().enumerate() {
            match node {
                TreeNode::Crate { name, .. } => {
                    // Always show crates
                    self.flat_visible_items.push(idx);
                }
                TreeNode::Section { crate_name, .. } => {
                    // Show if parent crate is expanded
                    if self.is_expanded(crate_name) {
                        self.flat_visible_items.push(idx);
                    }
                }
                TreeNode::Item { crate_name, section_name, .. } => {
                    // Show if parent section is expanded
                    let section_path = format!("{}/{}", crate_name, section_name);
                    if self.is_expanded(&section_path) {
                        self.flat_visible_items.push(idx);
                    }
                }
            }
        }
    }
    
    fn is_expanded(&self, path: &str) -> bool {
        self.expanded_paths.get(path).copied().unwrap_or(false)
    }
    
    fn toggle_expansion(&mut self, path: String, cx: &mut Context<Self>) {
        let is_expanded = self.is_expanded(&path);
        self.expanded_paths.insert(path, !is_expanded);
        self.rebuild_visible_list();
        cx.notify();
    }
    
    fn load_content(&mut self, path: &str, cx: &mut Context<Self>) {
        self.current_path = Some(path.to_string());
        
        if let Some(markdown) = get_doc_content(path) {
            self.markdown_content = markdown;
        } else {
            self.markdown_content = format!("# Error\n\nFailed to load documentation: {}", path);
        }
        
        cx.notify();
    }
}

impl Focusable for DocumentationWindow {
    fn focus_handle(&self, _cx: &App) -> FocusHandle {
        self.focus_handle.clone()
    }
}

impl Render for DocumentationWindow {
    fn render(&mut self, window: &mut Window, cx: &mut Context<Self>) -> impl IntoElement {
        let theme = cx.theme();
        
        div()
            .track_focus(&self.focus_handle)
            .size_full()
            .flex()
            .flex_col()
            .bg(theme.background)
            .child(
                // Header
                div()
                    .w_full()
                    .h_16()
                    .flex()
                    .items_center()
                    .px_4()
                    .gap_4()
                    .bg(theme.sidebar)
                    .border_b_1()
                    .border_color(theme.border)
                    .child(
                        div()
                            .text_lg()
                            .font_bold()
                            .text_color(theme.foreground)
                            .child("ðŸ“š Pulsar Engine Documentation")
                    )
                    .child(div().flex_1())
                    .child(
                        Button::new("refresh-docs")
                            .icon(IconName::Refresh)
                            .ghost()
                            .tooltip("Refresh Documentation")
                            .on_click(cx.listener(|this, _event, _window, cx| {
                                this.crates.clear();
                                this.load_documentation();
                                cx.notify();
                            }))
                    )
            )
            .child(
                // Main content area
                h_flex()
                    .flex_1()
                    .overflow_hidden()
                    .child(
                        // Sidebar
                        div()
                            .id("docs-sidebar")
                            .w_64()
                            .h_full()
                            .bg(theme.sidebar)
                            .border_r_1()
                            .border_color(theme.border)
                            .child(
                                div()
                                    .id("docs-sidebar-content")
                                    .h_full()
                                    .overflow_y_scroll()
                                    .child(
                                        v_flex()
                                            .w_full()
                                            .p_2()
                                            .gap_1()
                                            .children(
                                                self.crates.iter().map(|crate_doc| {
                                                    self.render_crate_item(crate_doc, cx)
                                                })
                                            )
                                    )
                            )
                    )
                    .child(
                        // Content area with markdown
                        div()
                            .id("docs-content")
                            .flex_1()
                            .h_full()
                            .overflow_y_scroll()
                            .child(
                                div()
                                    .w_full()
                                    .max_w(px(1200.0))
                                    .mx_auto()
                                    .p_8()
                                    .child(
                                        TextView::markdown(
                                            "docs-markdown",
                                            self.markdown_content.clone(),
                                            window,
                                            cx,
                                        )
                                    )
                            )
                    )
            )
    }
}

impl DocumentationWindow {
    fn render_crate_item(&self, crate_item: &CrateTreeItem, cx: &mut Context<Self>) -> AnyElement {
        let crate_name = crate_item.name.clone();
        let crate_name_for_toggle = crate_name.clone();
        let is_expanded = crate_item.is_expanded;
        
        v_flex()
            .w_full()
            .child(
                Button::new(SharedString::from(format!("crate-{}", crate_name)))
                    .w_full()
                    .justify_start()
                    .ghost()
                    .label(format!("{} {}", if is_expanded { "ðŸ“‚" } else { "ðŸ“¦" }, crate_item.name))
                    .on_click(cx.listener(move |this, _event, _window, cx| {
                        this.toggle_crate(&crate_name_for_toggle, cx);
                    }))
            )
            .when(is_expanded, |flex| {
                let sections = crate_item.index.sections.clone();
                let expanded_sections = crate_item.expanded_sections.clone();
                
                flex.children(
                    sections.iter().map(|section| {
                        self.render_section(&crate_name, section, &expanded_sections, cx)
                    })
                )
            })
            .into_any_element()
    }
    
    fn render_section(&self, crate_name: &str, section: &pulsar_docs::Section, expanded_sections: &[String], cx: &mut Context<Self>) -> AnyElement {
        let section_name = section.name.clone();
        let crate_name_clone = crate_name.to_string();
        let crate_name_for_toggle = crate_name.to_string();
        let section_name_for_toggle = section_name.clone();
        let is_expanded = expanded_sections.contains(&section_name);
        
        v_flex()
            .w_full()
            .child(
                Button::new(SharedString::from(format!("section-{}-{}", crate_name, section_name)))
                    .w_full()
                    .justify_start()
                    .ghost()
                    .small()
                    .pl_6()
                    .label(format!("{} {} ({})", if is_expanded { "â–¼" } else { "â–¶" }, section.name, section.count))
                    .on_click(cx.listener(move |this, _event, _window, cx| {
                        this.toggle_section(&crate_name_for_toggle, &section_name_for_toggle, cx);
                    }))
            )
            .when(is_expanded, |flex| {
                let items = section.items.clone();
                
                flex.children(
                    items.iter().map(|item| {
                        let item_path = format!("{}/{}", crate_name_clone, item.path);
                        let item_path_clone = item_path.clone();
                        let is_current = self.current_path == item_path;
                        
                        Button::new(SharedString::from(format!("item-{}", item_path)))
                            .w_full()
                            .justify_start()
                            .ghost()
                            .small()
                            .pl_12()
                            .label(item.name.clone())
                            .when(is_current, |btn| btn.selected())
                            .on_click(cx.listener(move |this, _event, _window, cx| {
                                this.load_content(&item_path_clone);
                                cx.notify();
                            }))
                            .into_any_element()
                    })
                )
            })
            .into_any_element()
    }
}

/// Helper to create documentation window with Root wrapper
pub fn create_documentation_window(window: &mut Window, cx: &mut App) -> Entity<Root> {
    let docs = cx.new(|cx| DocumentationWindow::new(window, cx));
    cx.new(|cx| Root::new(docs.into(), window, cx))
}
