//! # Node Metadata
//!
//! Provides access to Blueprint node metadata through the compile-time registry.
//!
//! Instead of parsing source files at runtime, this module uses the pre-built
//! registry generated by the `#[blueprint]` macro in `pulsar_std`. This provides:
//!
//! - **Fast startup** - No file I/O or parsing at runtime
//! - **Type safety** - Metadata is validated at compile time
//! - **Reliability** - No risk of parse errors or version mismatches
//!
//! ## Node Metadata Structure
//!
//! Each node in the registry contains:
//! - **Name** - Unique identifier (e.g., "add", "branch", "print_string")
//! - **Node Type** - Pure, Function, Control Flow, or Event
//! - **Category** - For organizing in the editor (e.g., "Math", "Logic")
//! - **Parameters** - Input pins with names and types
//! - **Return Type** - Output value type (if any)
//! - **Exec Pins** - Execution input/output pin names
//! - **Imports** - Required use statements for code generation
//! - **Source Code** - The actual Rust function body (for inlining)
//!
//! ## Node Types
//!
//! ### Pure (`NodeTypes::pure`)
//! Functions with no side effects and no execution pins.
//! Generated as inline expressions.
//!
//! ```rust,ignore
//! #[blueprint(type: NodeTypes::pure, category: "Math")]
//! fn add(a: i64, b: i64) -> i64 {
//!     a + b
//! }
//! ```
//!
//! ### Function (`NodeTypes::fn_`)
//! Functions with side effects and linear execution flow.
//! One exec in, one exec out.
//!
//! ```rust,ignore
//! #[blueprint(type: NodeTypes::fn_, category: "Debug")]
//! fn print_string(message: String) {
//!     println!("[DEBUG] {}", message);
//! }
//! ```
//!
//! ### Control Flow (`NodeTypes::control_flow`)
//! Functions that branch execution using `exec_output!()` macro.
//! One exec in, multiple exec outs.
//!
//! ```rust,ignore
//! #[blueprint(type: NodeTypes::control_flow, category: "Logic")]
//! fn branch(condition: bool) {
//!     if condition {
//!         exec_output!("True");
//!     } else {
//!         exec_output!("False");
//!     }
//! }
//! ```
//!
//! ### Event (`NodeTypes::event`)
//! Entry points for Blueprint execution (e.g., main, begin_play).
//! Become top-level functions in generated code.
//!
//! ```rust,ignore
//! #[blueprint(type: NodeTypes::event, category: "Events")]
//! fn main() {
//!     exec_output!("Body");
//! }
//! ```

use std::collections::HashMap;

// Re-export types from pulsar_std for API compatibility
pub use pulsar_std::{NodeMetadata, NodeTypes};

/// Extract all node metadata from the compile-time registry
///
/// This function accesses the registry built by the `#[blueprint]` macro processor
/// during compilation of pulsar_std. The registry contains all Blueprint-compatible
/// functions with their metadata pre-parsed and validated.
///
/// # Returns
///
/// * `Ok(HashMap)` - Map of node names to their metadata
/// * `Err(String)` - Error message if registry is unavailable
///
/// # Thread Safety
///
/// This function is thread-safe. The registry is built at compile time and stored
/// in static memory, so multiple threads can access it concurrently without locks.
///
/// # Examples
///
/// ```rust
/// use pulsar_engine::compiler::core::metadata::extract_node_metadata;
///
/// let nodes = extract_node_metadata().unwrap();
/// println!("Available nodes: {}", nodes.len());
///
/// if let Some(add_node) = nodes.get("add") {
///     println!("Add node: {} inputs", add_node.params.len());
/// }
/// ```
pub fn extract_node_metadata() -> Result<HashMap<String, NodeMetadata>, String> {
    let nodes = pulsar_std::get_all_nodes();

    if nodes.is_empty() {
        return Err("Node registry is empty - pulsar_std may not be compiled correctly".to_string());
    }

    Ok(nodes
        .iter()
        .map(|node| (node.name.to_string(), node.clone()))
        .collect())
}

/// Get nodes organized by category
///
/// Returns a map from category names to lists of nodes in that category.
/// Useful for building the node palette in the visual editor.
///
/// # Categories
///
/// Common categories include:
/// - "Math" - Arithmetic operations (add, multiply, etc.)
/// - "Logic" - Boolean operations and control flow (branch, and, or)
/// - "String" - String manipulation
/// - "Array" - Collection operations
/// - "Debug" - Debugging utilities (print_string, etc.)
/// - "Events" - Entry points (main, begin_play)
/// - "Threading" - Concurrency primitives
///
/// # Examples
///
/// ```rust
/// use pulsar_engine::compiler::core::metadata::get_nodes_by_category;
///
/// let by_category = get_nodes_by_category();
///
/// if let Some(math_nodes) = by_category.get("Math") {
///     println!("Math nodes:");
///     for node in math_nodes {
///         println!("  - {}", node.name);
///     }
/// }
/// ```
pub fn get_nodes_by_category() -> HashMap<String, Vec<&'static NodeMetadata>> {
    let mut categorized: HashMap<String, Vec<&'static NodeMetadata>> = HashMap::new();

    for node in pulsar_std::get_all_nodes() {
        categorized
            .entry(node.category.to_string())
            .or_insert_with(Vec::new)
            .push(node);
    }

    categorized
}

/// Get all available node categories
///
/// Returns a sorted list of all category names in the registry.
/// Useful for building category filters in the visual editor.
///
/// # Returns
///
/// A vector of category names in alphabetical order.
///
/// # Examples
///
/// ```rust
/// use pulsar_engine::compiler::core::metadata::get_categories;
///
/// let categories = get_categories();
/// println!("Available categories:");
/// for category in categories {
///     println!("  - {}", category);
/// }
/// ```
pub fn get_categories() -> Vec<String> {
    let mut categories: Vec<String> = pulsar_std::get_all_categories()
        .iter()
        .map(|s| s.to_string())
        .collect();
    
    categories.sort();
    categories
}

/// Find a node by name
///
/// Convenience function to look up a specific node's metadata.
///
/// # Arguments
///
/// * `name` - The node name to search for
///
/// # Returns
///
/// * `Some(&NodeMetadata)` - Reference to the node's metadata if found
/// * `None` - If no node with that name exists
///
/// # Examples
///
/// ```rust
/// use pulsar_engine::compiler::core::metadata::find_node;
///
/// if let Some(node) = find_node("add") {
///     println!("Found add node in category: {}", node.category);
/// }
/// ```
pub fn find_node(name: &str) -> Option<&'static NodeMetadata> {
    pulsar_std::get_all_nodes()
        .iter()
        .find(|node| node.name == name)
        .map(|node| node as &'static NodeMetadata)
}

/// Count nodes by type
///
/// Returns counts of how many nodes of each type are in the registry.
/// Useful for statistics and validation.
///
/// # Returns
///
/// A tuple of (pure_count, function_count, control_flow_count, event_count).
///
/// # Examples
///
/// ```rust
/// use pulsar_engine::compiler::core::metadata::count_nodes_by_type;
///
/// let (pure, func, control, event) = count_nodes_by_type();
/// println!("Registry contains:");
/// println!("  - {} pure nodes", pure);
/// println!("  - {} function nodes", func);
/// println!("  - {} control flow nodes", control);
/// println!("  - {} event nodes", event);
/// ```
pub fn count_nodes_by_type() -> (usize, usize, usize, usize) {
    let mut pure = 0;
    let mut func = 0;
    let mut control = 0;
    let mut event = 0;

    for node in pulsar_std::get_all_nodes() {
        match node.node_type {
            NodeTypes::pure => pure += 1,
            NodeTypes::fn_ => func += 1,
            NodeTypes::control_flow => control += 1,
            NodeTypes::event => event += 1,
        }
    }

    (pure, func, control, event)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_metadata() {
        let metadata = extract_node_metadata().unwrap();
        assert!(!metadata.is_empty(), "Should have registered nodes");

        // Check that common nodes exist
        assert!(metadata.contains_key("add"), "Should have 'add' node");
        assert!(metadata.contains_key("branch"), "Should have 'branch' node");
    }

    #[test]
    fn test_categorization() {
        let by_category = get_nodes_by_category();
        assert!(!by_category.is_empty(), "Should have at least one category");

        // Math category should exist and have nodes
        if let Some(math_nodes) = by_category.get("Math") {
            assert!(!math_nodes.is_empty(), "Math category should have nodes");
        }
    }

    #[test]
    fn test_find_node() {
        let add_node = find_node("add");
        assert!(add_node.is_some(), "Should find 'add' node");
        
        let add = add_node.unwrap();
        assert_eq!(add.node_type, NodeTypes::pure);
        assert_eq!(add.params.len(), 2, "Add should have 2 parameters");
    }

    #[test]
    fn test_count_by_type() {
        let (pure, func, control, event) = count_nodes_by_type();
        
        assert!(pure > 0, "Should have pure nodes");
        assert!(func > 0, "Should have function nodes");
        assert!(control > 0, "Should have control flow nodes");
        assert!(event > 0, "Should have event nodes");
        
        println!("Node type distribution:");
        println!("  Pure: {}", pure);
        println!("  Function: {}", func);
        println!("  Control Flow: {}", control);
        println!("  Event: {}", event);
    }

    #[test]
    fn test_get_categories() {
        let categories = get_categories();
        assert!(!categories.is_empty(), "Should have categories");
        
        // Should be sorted
        let mut sorted = categories.clone();
        sorted.sort();
        assert_eq!(categories, sorted, "Categories should be sorted");
    }
}
